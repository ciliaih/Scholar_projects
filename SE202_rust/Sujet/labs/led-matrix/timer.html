<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Monotonic timer - SE202 : Rust pour les systèmes embarqués</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../intro.html">Introduction</a></li><li class="chapter-item expanded "><a href="../../labs/fibo.html"><strong aria-hidden="true">1.</strong> Prise en main : Fibonacci</a></li><li class="chapter-item expanded "><a href="../../labs/vm/machine.html"><strong aria-hidden="true">2.</strong> A virtual machine in Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../labs/vm/specs.html"><strong aria-hidden="true">2.1.</strong> Specifications</a></li></ol></li><li class="chapter-item expanded "><a href="../../problems/problems.html"><strong aria-hidden="true">3.</strong> A few simple problems</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/led-matrix.html"><strong aria-hidden="true">4.</strong> LED matrix lab</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../labs/led-matrix/setup.html"><strong aria-hidden="true">4.1.</strong> Initial setup</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/structures.html"><strong aria-hidden="true">4.2.</strong> Visual data structures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../labs/led-matrix/color.html"><strong aria-hidden="true">4.2.1.</strong> Color</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/image.html"><strong aria-hidden="true">4.2.2.</strong> Image</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/reexport.html"><strong aria-hidden="true">4.2.3.</strong> Reexporting types</a></li></ol></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/embedded.html"><strong aria-hidden="true">4.3.</strong> Embedded mode</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../labs/led-matrix/toolchain.html"><strong aria-hidden="true">4.3.1.</strong> Configuring the toolchain</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/uploading.html"><strong aria-hidden="true">4.3.2.</strong> Uploading the program onto the board</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/execution.html"><strong aria-hidden="true">4.3.3.</strong> Displaying something</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/optimize-setup.html"><strong aria-hidden="true">4.3.4.</strong> Optimizing the setup</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/hal.html"><strong aria-hidden="true">4.3.5.</strong> Configuring the hardware</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/matrix.html"><strong aria-hidden="true">4.3.6.</strong> GPIO and the LED matrix</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/real-time.html"><strong aria-hidden="true">5.</strong> Real-time mode</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../labs/led-matrix/rtic.html"><strong aria-hidden="true">5.1.</strong> RTIC</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/timer.html" class="active"><strong aria-hidden="true">5.2.</strong> Monotonic timer</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/image-change.html"><strong aria-hidden="true">5.3.</strong> Image change</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/serial.html"><strong aria-hidden="true">5.4.</strong> Serial port</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/triple-buffering.html"><strong aria-hidden="true">5.5.</strong> Triple buffering</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/screen-saver.html"><strong aria-hidden="true">5.6.</strong> Screen saver</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/drawing.html"><strong aria-hidden="true">5.7.</strong> Drawing things</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SE202 : Rust pour les systèmes embarqués</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="monotonic-timer"><a class="header" href="#monotonic-timer">Monotonic timer</a></h1>
<p>In this part, we will start using a monotonic timer to run some tasks at designated times. For example, we want to display frames at a pace of 60 FPS (frames per second). Since each line of the matrix should get the same display time, we will call a display task 60×8=480 times per second. This display task will display the next line.</p>
<p>RTIC does not come with an implementation of a monotonic timer. Most timers are only 32 bits wide and cannot count for a very long time, so they have to be combined together and making it right and efficient is not a trivial task and may depend on the application requirements.</p>
<h2 id="dwtsystick-monotonic-timer"><a class="header" href="#dwtsystick-monotonic-timer">DWT+systick monotonic timer</a></h2>
<p>The <code>dwt-systick-monotonic</code> crate provides a <code>DwtSystick</code> timer which uses the DWT (data watchpoing and trace unit) and the systick timer together to form a long-running monotonic timer. This crate is still in prerelease mode.</p>
<p>❎ Add the <code>dwt-systick-monotonic</code> crate as a dependency to your <code>Cargo.toml</code>.</p>
<p>We need to declare a type alias for this monotonic timer and tell RTIC that it will be bound to the <code>SysTick</code> hardware interrupt. We will use the <code>MyMonotonic</code> name for that, and we will be able to refer to the timer methods as <code>monotonics::MyMonotonic::method()</code>. Since we will be using only one monotonic timer, we will tell RTIC that it is the default one, and we will be able to refer to the timer methods as <code>monotonics::method()</code> (without including <code>MyMonotonic</code>).</p>
<p>A monotonic timer can use a different frequency than the system one. However, the DWT+systick timer must use the same frequency as the system clock.</p>
<p>❎ Import <code>dwt_systick_monotonic::DwtSystick</code> and declare the monotonic timer type as the default one, with a 80MHz granularity in your RTIC application module:</p>
<pre><code class="language-rust no_run noplayground">#[monotonic(binds = SysTick, default = true)]
type MyMonotonic = DwtSystick&lt;80_000_000&gt;;</code></pre>
<p>❎ In your initialization task, create an instance of this timer and return it as the third element of the tuple:</p>
<pre><code class="language-rust no_run noplayground">
#[init]
fn init(cx: init::Context) -&gt; (Shared, Local, init::Monotonics) {
    …
    let mut mono = DwtSystick::new(&amp;mut cp.DCB, cp.DWT, cp.SYST, 80_000_000);
    …
    (Shared {}, Local { matrix }, init::Monotonics(mono))
}</code></pre>
<h2 id="display-task"><a class="header" href="#display-task">Display task</a></h2>
<p>We now have a monotonic timer running, but we do not use it for anything. We would like to use it to spawn a display task every time a new line should be displayed on the LED matrix in order to achieve a global 60 FPS refresh rate.</p>
<h3 id="hardware-interrupt-support-for-the-software-task"><a class="header" href="#hardware-interrupt-support-for-the-software-task">Hardware interrupt support for the software task</a></h3>
<p>This task will be spawned by software. However, RTIC uses hardware interrupts to schedule tasks, so we need to tell RTIC which interrupt is free to use. Since we do not plan to use the second serial interface (<code>USART2</code>), we will indicate so in the <code>#[rtic::app]</code> attribute using a <code>dispatchers</code> parameter. RTIC needs one free interrupt per priority level.</p>
<p>❎ Add a <code>dispatchers = [USART2]</code> parameter to your <code>rtic::app</code> attribute.</p>
<h3 id="declaration-of-the-task"><a class="header" href="#declaration-of-the-task">Declaration of the task</a></h3>
<p>We want to add a display task with the default priority (1). This task will access the local resource <code>matrix</code> (and will be the only task to do so, so the resource is still local indeed) and will display one line at a time. This task will also define a persistent local resource which does not require initialization in the init task, <code>next_line</code>, with the next line to display.</p>
<p>❎ Empty the idle task so that it just does an infinite <code>loop {}</code>. It does not need to access the <code>matrix</code> resource anymore.</p>
<p><em>Note: we could completely remove the idle task, and let RTIC use the default version. However, the default version puts the microcontroller on sleep where there is nothing to do using the <code>WFI</code> (wait for interrupt) assembly instruction. This would be fine in production, but RTT that we use to send debug messages does not work well with WFI, so an infinite loop is better in development even if it means the microcontroller is never going to save power by sleeping.</em></p>
<p>❎ Add an <code>image</code> (of type <code>Image</code>) to the <code>Local</code> structure and build the image you want to display in <code>init()</code>.</p>
<p>❎ Inside the RTIC application module, create the display task, and declare that it uses the <code>matrix</code> and <code>image</code> local resources, as well as a private local one <code>next_line</code> of type <code>usize</code> and initialized at 0:</p>
<pre><code class="language-rust no_run noplayground">#[task(local = [matrix, image, next_line: usize = 0])]
fn display(cx: display::Context) {
    // Display line next_line (cx.local.next_line) of
    // the image (cx.local.image) on the matrix (cx.local.matrix).
    // All those are mutable references.
    todo!()
    // Increment next_line up to 7 and wraparound to 0
    todo!()
}</code></pre>
<h3 id="display-task-spawning"><a class="header" href="#display-task-spawning">Display task spawning</a></h3>
<p>The display task never runs. We will first run it as fast as possible, by spawning it from the initialization task and spawning it again from the display task itself. A task is spawn by using <code>::spawn()</code> with arguments (if any) on its name. In our case, <code>display::spawn()</code> will start our task and returns a result if the task has been queued successfully (by default, a task can be queued one time only at any moment).</p>
<p>❎ Add <code>display::spawn().unwrap();</code> near the end of the initialization task so that the display task gets spawned after <code>init()</code> terminates.</p>
<p>❎ Add <code>display::spawn().unwrap();</code> in the display task so that it gets respawned as soon as the display task terminates since no task with a higher priority will be waiting.</p>
<p>Note that in practice the idle task will never run since the display task will always be executing or ready to execute, and its priority (1 by default) is greater than the idle task priority (0). You should not see &quot;In idle task&quot; in your RTT console.</p>
<h2 id="using-accurate-timing"><a class="header" href="#using-accurate-timing">Using accurate timing</a></h2>
<p>We want to display lines at a fixed rate (480 FPS, to get a 60 FPS image) rather than as fast as possible. To do so, we will give an argument to <code>display</code> corresponding to the reference time, <em>i.e.,</em> the theoretical date at which the task should have been launched. It will be used to compute the next date, and defer the spawn to this date as well as give the date as parameter to the function.</p>
<p><code>DwtSystick</code> instances implement <code>rtic::Monotonic</code> which defines a <code>Instant</code> associated type which defines a date.</p>
<p>❎ Right after your <code>MyMonotonic</code> type alias, define <code>Instant</code> as a new type alias to your monotonic timer type <code>Instant</code>:</p>
<pre><code class="language-rust no_run noplayground">type Instant = &lt;MyMonotonic as rtic::Monotonic&gt;::Instant;</code></pre>
<p>❎ In order to ease time computations on <code>Instant</code>, import <code>dwt_systick_monotonic::ExtU32</code>. This defines several functions on the <code>u32</code> integer types returning durations (instant differences) such as <code>5.secs()</code> (for 5 seconds).</p>
<p>❎ Make the display task take a <code>at</code> argument of type <code>Instant</code> which represents the exact date at which it should have been launched.</p>
<p>❎ Add the argument <code>mono.now()</code> in <code>init</code> <code>display::spawn()</code> occurrence to indicate that the first line theoretical display date is right now. The timer starts after <code>init()</code> terminates, so this corresponds to the correct date.</p>
<p>❎ In the display task itself, compute the <code>next</code> instant at which the next line should be displayed, from <code>at</code> and the desired period. You can compute the period by dividing <code>1.secs()</code> by 8 and by 60. Change <code>display::spawn()</code> by <code>display::spawn_at()</code> and pass the computed date both as the requested date and as the display task call argument.</p>
<p>❎ In the idle task, display something in the loop every ten thousands turns of the idle loop. You can use a local resource to count. Note that ten thousands can be written as <code>10_000</code> rather than <code>10000</code>, which is more easily readable.</p>
<p>You can now run your program. If everything goes well, the LED matrix should still display a smooth image, and in addition you should see many messages in the RTT console since display task spawns are now spaced by some time, so the idle task gets a chance to execute.</p>
<p>❎ Remove the RTT message from the idle task, letting only the infinite loop.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../labs/led-matrix/rtic.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../labs/led-matrix/image-change.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../labs/led-matrix/rtic.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../labs/led-matrix/image-change.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
