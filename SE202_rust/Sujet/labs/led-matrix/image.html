<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Image - SE202 : Rust pour les systèmes embarqués</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../intro.html">Introduction</a></li><li class="chapter-item expanded "><a href="../../labs/fibo.html"><strong aria-hidden="true">1.</strong> Prise en main : Fibonacci</a></li><li class="chapter-item expanded "><a href="../../labs/vm/machine.html"><strong aria-hidden="true">2.</strong> A virtual machine in Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../labs/vm/specs.html"><strong aria-hidden="true">2.1.</strong> Specifications</a></li></ol></li><li class="chapter-item expanded "><a href="../../problems/problems.html"><strong aria-hidden="true">3.</strong> A few simple problems</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/led-matrix.html"><strong aria-hidden="true">4.</strong> LED matrix lab</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../labs/led-matrix/setup.html"><strong aria-hidden="true">4.1.</strong> Initial setup</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/structures.html"><strong aria-hidden="true">4.2.</strong> Visual data structures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../labs/led-matrix/color.html"><strong aria-hidden="true">4.2.1.</strong> Color</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/image.html" class="active"><strong aria-hidden="true">4.2.2.</strong> Image</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/reexport.html"><strong aria-hidden="true">4.2.3.</strong> Reexporting types</a></li></ol></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/embedded.html"><strong aria-hidden="true">4.3.</strong> Embedded mode</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../labs/led-matrix/toolchain.html"><strong aria-hidden="true">4.3.1.</strong> Configuring the toolchain</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/uploading.html"><strong aria-hidden="true">4.3.2.</strong> Uploading the program onto the board</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/execution.html"><strong aria-hidden="true">4.3.3.</strong> Displaying something</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/optimize-setup.html"><strong aria-hidden="true">4.3.4.</strong> Optimizing the setup</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/hal.html"><strong aria-hidden="true">4.3.5.</strong> Configuring the hardware</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/matrix.html"><strong aria-hidden="true">4.3.6.</strong> GPIO and the LED matrix</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/real-time.html"><strong aria-hidden="true">5.</strong> Real-time mode</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../labs/led-matrix/rtic.html"><strong aria-hidden="true">5.1.</strong> RTIC</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/timer.html"><strong aria-hidden="true">5.2.</strong> Monotonic timer</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/image-change.html"><strong aria-hidden="true">5.3.</strong> Image change</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/serial.html"><strong aria-hidden="true">5.4.</strong> Serial port</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/triple-buffering.html"><strong aria-hidden="true">5.5.</strong> Triple buffering</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/screen-saver.html"><strong aria-hidden="true">5.6.</strong> Screen saver</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/drawing.html"><strong aria-hidden="true">5.7.</strong> Drawing things</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SE202 : Rust pour les systèmes embarqués</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="image"><a class="header" href="#image">Image</a></h1>
<p>We want to manipulate images as a whole. Images are a collection of 64 <code>Color</code> pixels.</p>
<p>❎ Create a public structure <code>image::Image</code> containing a unique unnamed field consisting of an array of 64 <code>Color</code>. Structure with unnamed fields are declared as follow, and fields are access like tuple fields (<code>.0</code> to access the first field, <code>.1</code> to access the second field, …):</p>
<pre><code class="language-rust no_run noplayground">struct Image([Color; 64]);</code></pre>
<p>❎ Create a public function <code>pub fn new_solid(color: Color) -&gt; Self</code> on <code>Image</code> which returns an image filled with the color given as an argument.</p>
<h4 id="default-trait"><a class="header" href="#default-trait">Default trait</a></h4>
<p>Unfortunately, the trait <code>Default</code> cannot be derived automatically for <code>Image</code> because of a temporary technical limitation of the Rust language: arrays with more than 32 entries cannot have <code>Default</code> derived automatically. However, nothing prevents us from implementing the <code>Default</code> trait manually.</p>
<p>❎ Implement the <code>Default</code> trait for <code>Image</code> by making it return an image filled with the default color.</p>
<h4 id="individual-pixel-access"><a class="header" href="#individual-pixel-access">Individual pixel access</a></h4>
<p>We want to be able to access an individual pixel of an image by using an expression such as <code>my_image[(row, column)]</code>. For doing so, we want to implement two traits, <code>Index</code> and <code>IndexMut</code>, which allow indexing into our data structure. Fortunately, Rust lets us use any type as an index, so a <code>(usize, usize)</code> couple looks perfectly appropriate.</p>
<p>❎ Implement the <code>core::ops::Index&lt;(usize, usize)&gt;</code> trait on <code>Image</code> with output type <code>Color</code>.</p>
<p>❎ Implement the <code>core::ops::IndexMut&lt;(usize, usize)&gt;</code> trait on <code>Image</code>. Note that you do not specify the output type as it is necessarily identical to the one defined in <code>Index</code>, as <code>IndexMut</code> can only be implemented on types also implementing <code>Index</code> with the same index type.</p>
<h4 id="row-access"><a class="header" href="#row-access">Row access</a></h4>
<p>Since we will display the image one row at a time on the led matrix, it might be useful to have a method giving access to the content of one particular row.</p>
<p>❎ Add a <code>pub fn row(&amp;self, row: usize) -&gt; &amp;[Color]</code> on <code>Image</code> referencing the content of a particular row.</p>
<p>Note how the reference will stay valid no longer than the image itself; for this reason, Rust lets us take a reference inside a structure without any risk for the reference to become invalid if the image is destroyed.</p>
<h4 id="gradient"><a class="header" href="#gradient">Gradient</a></h4>
<p>For visual testing purpose, we would like to be able to build a gradient from a given color to black. Each pixel should receive the reference color divided by <code>(1 + row * row + col)</code>.</p>
<p>❎ Using the <code>image[(row, col)]</code> utilities defined in previous steps, implement a <code>pub fn gradient(color: Color) -&gt; Self</code> function returning an image containing a gradient.</p>
<h4 id="image-as-an-array-of-bytes"><a class="header" href="#image-as-an-array-of-bytes">Image as an array of bytes</a></h4>
<p>We already know from the SE203 lab that we will receive image bytes from the serial port, and that we will build the image byte by byte. It would be much easier if we could also see the image as a slice and access the individual bytes.</p>
<p>Remember that Rust is allowed to reorder, group, or otherwise rearrange fields in a struct. It means that so far we have no idea of how the <code>Color</code> type is organized in memory. Maybe each field is stored on 32 bits instead of 8, or maybe <code>g</code> is stored first, before <code>r</code> and <code>b</code>. We will use a representation clause to force Rust to make each field 8 bits wide, to have a one byte alignment only on the structure, and to keep <code>r</code>, <code>g</code> and <code>b</code> in the order we have chosen.</p>
<p>❎ Force Rust to use a C compatible representation for <code>Color</code> by using the appropriate <code>repr(C)</code> attribute. It will ensure all properties mentioned above.</p>
<p>Concerning the <code>Image</code> type itself, we do not have much to do. We already know that Rust arrays are guaranteed to be layed out according to the size and alignment requirements of the element type. In our case, it means that the three bytes of the first pixel will be immediately followed by the three bytes of the second pixel, and so on.</p>
<p>However, to guarantee that Rust uses the same representation for <code>Image</code> as the one it uses for the inner array, we need to request that the <code>Image</code> type is transparent, i.e., that it uses the same representation as its unique non-zero-sized field.</p>
<p>❎ Add a <code>repr(transparent)</code> attribute on the <code>Image</code> type to ensure that it keeps the same representation as its unique element.</p>
<p>To see an image as an immutable array of bytes, we will implement the <code>AsRef&lt;[u8; 192]&gt;</code> trait. This way, using <code>my_image.as_ref()</code> will return a reference to an array of 192 (8 rows × 8 columns × 3 color bytes) individual bytes.</p>
<p>❎ Implement <code>AsRef&lt;[u8; 192]&gt;</code> for <code>Image</code>. You will need to use <code>core::mem::transmute()</code>, which is an <em>unsafe</em> function, in order to convert <code>self</code> to the desired return value.</p>
<p>❎ Since we know we will need a mutable reference to the individual bytes, implement <code>AsMut&lt;[u8; 192]&gt;</code> the same way.</p>
<p>Congratulations, you now have a rock-solid <code>Image</code> type which will make the rest of the job easier.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../labs/led-matrix/color.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../labs/led-matrix/reexport.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../labs/led-matrix/color.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../labs/led-matrix/reexport.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
