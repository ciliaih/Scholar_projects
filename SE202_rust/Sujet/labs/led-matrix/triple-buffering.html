<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Triple buffering - SE202 : Rust pour les systèmes embarqués</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../intro.html">Introduction</a></li><li class="chapter-item expanded "><a href="../../labs/fibo.html"><strong aria-hidden="true">1.</strong> Prise en main : Fibonacci</a></li><li class="chapter-item expanded "><a href="../../labs/vm/machine.html"><strong aria-hidden="true">2.</strong> A virtual machine in Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../labs/vm/specs.html"><strong aria-hidden="true">2.1.</strong> Specifications</a></li></ol></li><li class="chapter-item expanded "><a href="../../problems/problems.html"><strong aria-hidden="true">3.</strong> A few simple problems</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/led-matrix.html"><strong aria-hidden="true">4.</strong> LED matrix lab</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../labs/led-matrix/setup.html"><strong aria-hidden="true">4.1.</strong> Initial setup</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/structures.html"><strong aria-hidden="true">4.2.</strong> Visual data structures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../labs/led-matrix/color.html"><strong aria-hidden="true">4.2.1.</strong> Color</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/image.html"><strong aria-hidden="true">4.2.2.</strong> Image</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/reexport.html"><strong aria-hidden="true">4.2.3.</strong> Reexporting types</a></li></ol></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/embedded.html"><strong aria-hidden="true">4.3.</strong> Embedded mode</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../labs/led-matrix/toolchain.html"><strong aria-hidden="true">4.3.1.</strong> Configuring the toolchain</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/uploading.html"><strong aria-hidden="true">4.3.2.</strong> Uploading the program onto the board</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/execution.html"><strong aria-hidden="true">4.3.3.</strong> Displaying something</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/optimize-setup.html"><strong aria-hidden="true">4.3.4.</strong> Optimizing the setup</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/hal.html"><strong aria-hidden="true">4.3.5.</strong> Configuring the hardware</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/matrix.html"><strong aria-hidden="true">4.3.6.</strong> GPIO and the LED matrix</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/real-time.html"><strong aria-hidden="true">5.</strong> Real-time mode</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../labs/led-matrix/rtic.html"><strong aria-hidden="true">5.1.</strong> RTIC</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/timer.html"><strong aria-hidden="true">5.2.</strong> Monotonic timer</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/image-change.html"><strong aria-hidden="true">5.3.</strong> Image change</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/serial.html"><strong aria-hidden="true">5.4.</strong> Serial port</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/triple-buffering.html" class="active"><strong aria-hidden="true">5.5.</strong> Triple buffering</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/screen-saver.html"><strong aria-hidden="true">5.6.</strong> Screen saver</a></li><li class="chapter-item expanded "><a href="../../labs/led-matrix/drawing.html"><strong aria-hidden="true">5.7.</strong> Drawing things</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SE202 : Rust pour les systèmes embarqués</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="triple-buffering"><a class="header" href="#triple-buffering">Triple buffering</a></h1>
<p>Our current handling of the image received on the serial port is not very satisfying. As soon as we have received a full image, we update the shared image: it means that the next rows to be displayed will come from the newer image while some rows on the LED matrix may have come from the older image.</p>
<p><strong>⚠ You do not have to implement double-buffering. You have to understand how it works, but you only need to implement triple-buffering.</strong></p>
<h2 id="what-is-double-buffering"><a class="header" href="#what-is-double-buffering">What is double-buffering?</a></h2>
<p>In older computers, drawing something was performed directly in the screen buffer (also called the video RAM) as memory was tight. It meant that some artifacts could easily be perceived unless extreme caution was observed. For example, if an image was displayed by a beam going from the top to the bottom of the screen, drawing a shape starting from the bottom of the screen would make the bottom half of the shape appear before the top half does. On the other hand, drawing from the bottom to the top at the same pace as the refreshing beam would display consistent pictures.</p>
<p>As memory became more affordable, people started to draw the next image to display into a back buffer. This process lets software draw things in an order which is not correlated with the beam displaying the image (for example objects far away then nearer objects). Once the new image is complete, it can be transferred into the front buffer (the video RAM) while ensuring that the transfer does not cross the beam, which requires synchronization with the hardware. This way, only full images are displayed in a consistent way.</p>
<p>On some hardware, both buffers fit in video RAM. In this case, switching buffer at the appropriate time is done by modifying a hardware register at the appropriate time.</p>
<h2 id="double-buffering-in-our-project"><a class="header" href="#double-buffering-in-our-project">Double-buffering in our project</a></h2>
<p>We already implement part of the double-buffering method in our code: we prepare the next image in a separate buffer while the current one is being displayed in a loop. We could modify our code (<strong>⚠ again, you do not need to implement double-buffering, this is only an example, you'll implement triple-buffering</strong>) so that the image switching takes place at the appropriate time:</p>
<ul>
<li>Make the new image a shared resource <code>next_image</code> rather than a local resource.</li>
<li>Add a shared boolean <code>switch_requested</code> to the <code>Shared</code> state, and set it in <code>receive_byte</code> when the new image is complete.</li>
<li>Have the <code>display</code> task check the <code>switch_requested</code> boolean after displaying the last row of the current image, and swap the <code>image</code> and <code>next_image</code> if this is the case and reset <code>switch_requested</code>.</li>
</ul>
<p>By locking <code>next_image</code> and <code>switch_requested</code> for the shortest possible time, the <code>receive_byte</code> task would prevent the <code>display</code> task from running for very short periods. However, we could still run into an issue in the following scenario:</p>
<ul>
<li>The last byte of the next image is received just as the current image starts displaying.</li>
<li>We set <code>switch_requested</code> to request the image switch, but this will happen after the whole current image as been displayed (roughly 1/60 seconds later, or 17ms).</li>
<li>The speed of the serial port is 38400 bits per second, and a byte requires 10 symbols (start, 8 bits, stop).</li>
<li>It means that while the current image is being displayed, about 64 bytes of the next-next image can be received.</li>
</ul>
<p>Where can we store those bytes? If we store them in <code>next_image</code>, we will alter a buffer which has been fully drawn but not displayed yet so we cannot do this. We cannot obviously store them in <code>image</code> either. There is nothing we can do there.</p>
<h2 id="triple-buffering-1"><a class="header" href="#triple-buffering-1">Triple buffering</a></h2>
<p>We need a third buffer: one buffer is the one currently being displayed, one buffer is the next fully completed image ready to be displayed, and one buffer is the work area where we build the currently incomplete image.</p>
<p>In order to avoid copying whole images around, we would like to work with buffer references and switch those references. Should we use dynamic memory allocation? ☠ Certainly not.</p>
<h3 id="the-heapless-crate"><a class="header" href="#the-heapless-crate">The <code>heapless</code> crate</a></h3>
<p>The <a href="https://docs.rs/heapless"><code>heapless</code> crate</a> contains several data structures that can be used in environments where dynamic memory allocation is not available or not desirable:</p>
<ul>
<li><code>heapless::Vec&lt;T&gt;</code> has an interface quite similar to <code>std::vec::Vec&lt;T&gt;</code> except that those vectors have a fixed capacity, which means that the <code>push</code> operation returns a <code>Result</code> indicating if the operation succeeded or failed (in which case it returns the element we tried to push).</li>
<li>Other structures such as <code>BinaryHeap</code>, <code>IndexMap</code>, <code>IndexSet</code>, <code>String</code>, etc. act closely like the standard library ones.</li>
<li><code>Pool</code> is a lock-free memory pool which gives away and can reclaim fixed size objects: this is the one we are interested in.</li>
</ul>
<h3 id="using-a-pool"><a class="header" href="#using-a-pool">Using a pool</a></h3>
<p>By using a pool, we will be able to manipulate values of type <code>Box&lt;Image&gt;</code>: this type represents a pointer to an image. By manipulating <code>Box&lt;Image&gt;</code> instead of <code>Image</code>, we will be able to exchange pointers rather than exchanging whole image contents.</p>
<p>We will use three types from the <code>heapless::pool</code> module:</p>
<ul>
<li><code>Box&lt;T&gt;</code> is similar to the standard library <code>std::box::Box&lt;T&gt;</code>, and owns an object of type <code>T</code>.</li>
<li><code>Node&lt;T&gt;</code> represents the in-memory data structure holding the memory area for one object of type <code>T</code> and administrative information about the next node.</li>
<li><code>Pool&lt;T&gt;</code> represents a pool that can hold boxed references to objects of type <code>T</code>.</li>
</ul>
<p>A pool is created using <code>Pool::new()</code> and contains no object. The method <code>grow_exact()</code> takes a static slice of uninitialized nodes. The curious student will read the documentation of <a href="https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html"><code>MaybeUninit</code></a>, but for everyone here is how one can initialize a pool containing three <code>Image</code> objects:</p>
<pre><code class="language-rust no_run noplayground">  let pool: Pool&lt;Image&gt; = Pool::new();
  unsafe {
    static mut MEMORY: MaybeUninit&lt;[Node&lt;Image&gt;; 3]&gt; = MaybeUninit::uninit();
    pool.grow_exact(&amp;mut MEMORY);   // static mut access is unsafe
  }</code></pre>
<ul>
<li>This pool can hand out <code>Box&lt;Image, Uninit&gt;</code> through <code>pool.alloc()</code> which returns an <code>Option&lt;Box&lt;Image, Uninit&gt;&gt;</code>.</li>
<li>A <code>Box&lt;Image, Uninit&gt;</code> can be transformed into a <code>Box&lt;Image&gt;</code> (which is a shortcut for <code>Box&lt;Image, Init&gt;</code>) by calling its <code>init</code> method with the initial value.</li>
<li>When it is no longer used, a <code>Box&lt;Image&gt;</code> or <code>Box&lt;Image, Uninit&gt;</code> is returned to the pool by using <code>pool.free(image)</code>.</li>
</ul>
<p>Isn't that simple enough? By the way, note that <code>pool.alloc()</code> and <code>pool.free()</code> only require a non-mutable reference to the pool.</p>
<h3 id="useful-functions"><a class="header" href="#useful-functions">Useful functions</a></h3>
<p>Before modifying your code, make sure you know of those useful methods when working with mutable references. The problem here is that
when you get lent a mutable reference onto an object, you cannot easily become the owner of the referenced object as the reference would not designate a valid object anymore. However, you can:</p>
<ul>
<li>Use <code>core::mem::swap()</code> to exchange the object with another object you own of the same type. This way, the reference stays valid as it points onto another object now.</li>
<li>Use <code>Option::take()</code> when you want to take the content of an <code>Option&lt;T&gt;</code> that you do not own, this will replace it by <code>None</code> which is a valid object.</li>
</ul>
<h4 id="corememswap"><a class="header" href="#corememswap"><code>core::mem::swap()</code></a></h4>
<p>When <code>a</code> et <code>b</code> are mutable references of the same type <code>&amp;mut T</code>, <code>core::mem::swap(a, b)</code> will exchange the content of <code>a</code> and <code>b</code>. This is a great way to exchange something contained in a mutable reference with something we own locally:</p>
<pre><pre class="playground"><code class="language-rust">type LargeArray = [u8; 1000];

fn exchange(a: &amp;mut Box&lt;LargeArray&gt;) {
  // How can we become owner of the `Box&lt;LargeArray&gt;` referenced by `a`?
  // We can exchange it with another object of the same type.
  // Let's create one.
  let mut b: Box&lt;LargeArray&gt; = Box::new([42; 1000]);

  // Let's exchange the object we own in `b` by the one referenced by `a`
  // (both objects are of type `Box&lt;Image&gt;`).
  core::mem::swap(a, &amp;mut b);

  // We now own in `b` the Box&lt;LargeArray&gt; that was in `a`,
  // and `a` now contains the Box&lt;LargeArray&gt; that was in `b`.
  // We exchanged the boxes (pointers), the `LargeArray` arrays
  // themselves were not moved around.

  // At the end of this function, `b` will be dropped, so the `LargeArray`
  // which was initially passed in `a` will be deallocated (because the
  // destructor of `Box` deallocates its content).
}

fn main() {
  let mut a: Box&lt;LargeArray&gt; = Box::new([10; 1000]);
  println!(&quot;a[0] = {}&quot;, a[0]);   // Will print 10
  exchange(&amp;mut a);
  println!(&quot;a[0] = {}&quot;, a[0]);   // Will print 42
}</code></pre></pre>
<p>Note that there is nothing unsafe in doing that.</p>
<h4 id="optiontake"><a class="header" href="#optiontake"><code>Option::take()</code></a></h4>
<p>When <code>opt</code> is a mutable reference of type <code>&amp;mut Option&lt;T&gt;</code>, <code>opt.take()</code> returns the content of <code>opt</code> and replaces it by <code>None</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn display_option(opt: &amp;mut Option&lt;&amp;str&gt;) {
  if let Some(s) = opt.take() {   // Take the String if any and put None into opt
    println!(&quot;I have taken ownership of the string, which was: {s}&quot;);
  } else {
    println!(&quot;There was nothing in the opt&quot;);
  }
}

fn main() {
  let mut opt = Some(&quot;Hello, world&quot;);
  display_option(&amp;mut opt);    // Will display the string and put None into opt
  display_option(&amp;mut opt);    // Will indicate that there is nothing in the opt
}</code></pre></pre>
<p>Of course we could have used <code>core::mem::swap()</code> as well, but <code>Option::take()</code> is more idiomatic. Here is a version with <code>swap()</code> anyway:</p>
<pre><pre class="playground"><code class="language-rust">fn display_option(opt: &amp;mut Option&lt;&amp;str&gt;) {
  let mut empty = None;
  core::mem::swap(&amp;mut empty, opt);
  
  // What was referenced by `opt` is now in `empty`
  // and what was in `empty` is now referenced by `opt`.
  // Let's check it with an `assert!()`.
  assert!(opt.is_none());

  if let Some(s) = empty {   // `empty` now contains what was in `opt`
    println!(&quot;I have taken ownership of the string, which was: {s}&quot;);
  } else {
    println!(&quot;There was nothing in the opt&quot;);
  }
}

fn main() {
  let mut opt = Some(&quot;Hello, world&quot;);
  display_option(&amp;mut opt);    // Will display the string and put None into opt
  display_option(&amp;mut opt);    // Will indicate that there is nothing in the opt
}</code></pre></pre>
<p>There also exists <code>Option::replace()</code> which takes the content of an <code>Option&lt;T&gt;</code>
we have a reference onto and replaces it with <code>Some</code> value.</p>
<h3 id="using-the-triple-buffering-in-our-code"><a class="header" href="#using-the-triple-buffering-in-our-code">Using the triple buffering in our code</a></h3>
<p>Our shared state will be modified to include those fields:</p>
<ul>
<li><code>next_image: Option&lt;Box&lt;Image&gt;&gt;</code>: the next image to display if one is ready;</li>
<li><code>pool: Pool&lt;Image&gt;</code>: the pool from which to draw or return <code>Box&lt;Image&gt;</code> buffers.</li>
</ul>
<p>Our local state will include those fields (used in their respective task):</p>
<ul>
<li><code>current_image: Box&lt;Image&gt;</code>: the image currently being displayed by the <code>display</code> task;</li>
<li><code>rx_image: Box&lt;Image&gt;</code>: the image currently being filled by the <code>receive_byte</code> task.</li>
</ul>
<p>❎ Modify the <code>Shared</code> and <code>Local</code> structs to include the fields described above and initialize them from the <code>#[init]</code> task. The initial <code>current_image</code> and <code>rx_image</code> must be drawn from the pool and initialized with <code>Image::default()</code>. <code>next_image</code> will be initialized to <code>None</code> since there is no next image ready to display.</p>
<p>❎ Modify the <code>display</code> task so that it sends a row from the <code>current_image</code> local resource of type <code>Box&lt;Image&gt;</code>. When the last row is displayed, if <code>next_image</code> contains an image, <code>take()</code> it in a variable <code>image</code> and <code>swap()</code> it with <code>current_image</code>. Return the old image (which is now in <code>image</code> after the swap) to the pool.</p>
<p>❎ In the <code>receive_byte</code> task, fill the <code>rx_image</code> local resource of type <code>Box&lt;Image&gt;</code>.</p>
<p>❎ In the <code>receive_byte</code> task, once the <code>rx_image</code> is complete, you must do the following:</p>
<ol>
<li>If <code>next_image</code> contains an image, <code>take()</code> it and return it to the pool. Note that it represents an image which was ready to be displayed but did not get a chance to be displayed yet. This could happen in the future if we prepared images from different tasks in a rapid succession.</li>
<li>Obtain a <code>future_image</code> from the pool, and install it (by <code>swap()</code>-ping them) as the future <code>rx_image</code>.</li>
<li>Store the completed image (which is now in <code>future_image</code> after the swap) in <code>next_image</code> so that it will be displayed soon.</li>
</ol>
<p>Well done, you are now using triple buffering for a very smooth display! Ensure everything looks nice and be proud of yourself.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../labs/led-matrix/serial.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../labs/led-matrix/screen-saver.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../labs/led-matrix/serial.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../labs/led-matrix/screen-saver.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
